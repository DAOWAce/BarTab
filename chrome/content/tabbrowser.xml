<?xml version="1.0"?>

<!-- ***** BEGIN LICENSE BLOCK *****
   - Version: MPL 1.1/GPL 2.0/LGPL 2.1
   -
   - The contents of this file are subject to the Mozilla Public License Version
   - 1.1 (the "License"); you may not use this file except in compliance with
   - the License. You may obtain a copy of the License at
   - http://www.mozilla.org/MPL/
   -
   - Software distributed under the License is distributed on an "AS IS" basis,
   - WITHOUT WARRANTY OF ANY KIND, either express or implied. See the License
   - for the specific language governing rights and limitations under the
   - License.
   -
   - The Original Code is this file as it was released on March 28, 2001.
   -
   - The Initial Developer of the Original Code is
   - David Hyatt.
   - Portions created by the Initial Developer are Copyright (C) 2001
   - the Initial Developer. All Rights Reserved.
   -
   - Contributor(s):
   -   David Hyatt <hyatt@netscape.com> (Original Author of <tabbrowser>)
   -   Mike Connor <mconnor@steelgryphon.com>
   -   Peter Parente <parente@cs.unc.edu>
   -   Giorgio Maone <g.maone@informaction.com>
   -   Asaf Romano <mozilla.mano@sent.com>
   -   Seth Spitzer <sspitzer@mozilla.org>
   -   Simon Bünzli <zeniko@gmail.com>
   -   Michael Ventnor <ventnor.bugzilla@yahoo.com.au>
   -   Mark Pilgrim <pilgrim@gmail.com>
   -   Dão Gottwald <dao@mozilla.com>
   -   Paul O’Shannessy <paul@oshannessy.com>
   -   Rob Arnold <tellrob@gmail.com>
   -
   - Alternatively, the contents of this file may be used under the terms of
   - either the GNU General Public License Version 2 or later (the "GPL"), or
   - the GNU Lesser General Public License Version 2.1 or later (the "LGPL"),
   - in which case the provisions of the GPL or the LGPL are applicable instead
   - of those above. If you wish to allow use of your version of this file only
   - under the terms of either the GPL or the LGPL, and not to allow others to
   - use your version of this file under the terms of the MPL, indicate your
   - decision by deleting the provisions above and replace them with the notice
   - and other provisions required by the GPL or the LGPL. If you do not delete
   - the provisions above, a recipient may use your version of this file under
   - the terms of any one of the MPL, the GPL or the LGPL.
   -
   - ***** END LICENSE BLOCK ***** -->

<!DOCTYPE bindings [
<!ENTITY % tabBrowserDTD SYSTEM "chrome://browser/locale/tabbrowser.dtd" >
%tabBrowserDTD;
]>

<bindings id="tabBrowserBindings"
          xmlns="http://www.mozilla.org/xbl"
          xmlns:xul="http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul"
          xmlns:xbl="http://www.mozilla.org/xbl">

  <binding id="tabbrowser"
           extends="chrome://browser/content/tabbrowser.xml#tabbrowser">

    <implementation>

      <!-- A web progress listener object definition for a given tab. -->
      <method name="mTabProgressListener">
        <parameter name="aTab"/>
        <parameter name="aBrowser"/>
        <parameter name="aStartsBlank"/>
        <body>
        <![CDATA[
          return ({
            mTabBrowser: this,
            mTab: aTab,
            mBrowser: aBrowser,
            mBlank: aStartsBlank,

            // cache flags for correct status bar update after tab switching
            mStateFlags: 0,
            mStatus: 0,
            mMessage: "",
            mTotalProgress: 0,

            // count of open requests (should always be 0 or 1)
            mRequestCount: 0,

            onProgressChange : function (aWebProgress, aRequest,
                                         aCurSelfProgress, aMaxSelfProgress,
                                         aCurTotalProgress, aMaxTotalProgress)
            {
              this.mTotalProgress = aMaxTotalProgress ? aCurTotalProgress / aMaxTotalProgress : 0;

              if (this.mBlank)
                return;

              if (this.mTabBrowser.mCurrentTab == this.mTab) {
                for (let i = 0; i < this.mTabBrowser.mProgressListeners.length; i++) {
                  let p = this.mTabBrowser.mProgressListeners[i];
                  if (p)
                    try {
                      p.onProgressChange(aWebProgress, aRequest,
                                         aCurSelfProgress, aMaxSelfProgress,
                                         aCurTotalProgress, aMaxTotalProgress);
                    } catch (e) {
                      // don't inhibit other listeners
                      Components.utils.reportError(e);
                    }
                }
              }

              for (let i = 0; i < this.mTabBrowser.mTabsProgressListeners.length; i++) {
                let p = this.mTabBrowser.mTabsProgressListeners[i];
                if (p)
                  try {
                    p.onProgressChange(this.mBrowser, aWebProgress, aRequest,
                                       aCurSelfProgress, aMaxSelfProgress,
                                       aCurTotalProgress, aMaxTotalProgress);
                  } catch (e) {
                    // don't inhibit other listeners
                    Components.utils.reportError(e);
                  }
              }
            },

            onProgressChange64 : function (aWebProgress, aRequest,
                                         aCurSelfProgress, aMaxSelfProgress,
                                         aCurTotalProgress, aMaxTotalProgress)
            {
              return this.onProgressChange(aWebProgress, aRequest,
                aCurSelfProgress, aMaxSelfProgress, aCurTotalProgress,
                aMaxTotalProgress);
            },

            onStateChange : function(aWebProgress, aRequest, aStateFlags, aStatus)
            {
              if (!aRequest)
                return;

              var oldBlank = this.mBlank;

              const nsIWebProgressListener = Components.interfaces.nsIWebProgressListener;
              const nsIChannel = Components.interfaces.nsIChannel;

              if (aStateFlags & nsIWebProgressListener.STATE_START) {
                this.mRequestCount++;
              }
              else if (aStateFlags & nsIWebProgressListener.STATE_STOP) {
                const NS_ERROR_UNKNOWN_HOST = 2152398878;
                if (--this.mRequestCount > 0 && aStatus == NS_ERROR_UNKNOWN_HOST) {
                  // to prevent bug 235825: wait for the request handled
                  // by the automatic keyword resolver
                  return;
                }
                // since we (try to) only handle STATE_STOP of the last request,
                // the count of open requests should now be 0
                this.mRequestCount = 0;
              }

              if (aStateFlags & nsIWebProgressListener.STATE_START &&
                  aStateFlags & nsIWebProgressListener.STATE_IS_NETWORK) {
                // It's okay to clear what the user typed when we start
                // loading a document. If the user types, this counter gets
                // set to zero, if the document load ends without an
                // onLocationChange, this counter gets decremented
                // (so we keep it while switching tabs after failed loads)
                // We need to add 2 because loadURIWithFlags may have
                // cancelled a pending load which would have cleared
                // its anchor scroll detection temporary increment.
                if (aWebProgress.DOMWindow == this.mBrowser.contentWindow)
                  this.mBrowser.userTypedClear += 2;

                if (!this.mBlank) {
                  if (!(aStateFlags & nsIWebProgressListener.STATE_RESTORING)) {

                    /* philiKON's changes here */
                    if (this.mBrowser.getAttribute("putitonmytap") == "true") {
                      var browser = this.mBrowser;
                      browser.stop();

                      browser.addEventListener("BarTapLoad", function() {
                          browser.removeAttribute("putitonmytap");

                          let history =  browser.webNavigation.sessionHistory;
                          let bartap = browser.getAttribute("bartap");

                          if (bartap) {
                            /* The tab was likely opened by clicking on a link */
                            browser.removeAttribute("bartap");
                            bartap = JSON.parse(bartap);

                            /* Gotta love the inconsistency of this API */
                            browser.loadURIWithFlags(
                              bartap.uri, bartap.flags, makeURI(bartap.referrer),
                              bartap.charset, bartap.postdata);
                          } else if (history.count) {
                            /* Likely a restored tab, try loading from history. */
                            let gotoindex = history.requestedIndex;
                            if (gotoindex == -1) {
                              gotoindex = history.index;
                            }
                            browser.webNavigation.gotoIndex(gotoindex);
                          } else if (browser.userTypedValue) {
                            /* This might not make much sense here... */
                            browser.loadURI(browser.userTypedValue);
                          }
                        }, false);
                    }

                    this.mTab.setAttribute("busy", "true");
                    this.mTabBrowser.updateIcon(this.mTab);
                    this.mTabBrowser.setTabTitleLoading(this.mTab);
                  }

                  if (this.mTabBrowser.mCurrentTab == this.mTab)
                    this.mTabBrowser.mIsBusy = true;
                }
              }
              else if (aStateFlags & nsIWebProgressListener.STATE_STOP &&
                       aStateFlags & nsIWebProgressListener.STATE_IS_NETWORK) {
                if (aWebProgress.DOMWindow == this.mBrowser.contentWindow) {
                  // The document is done loading, we no longer want the
                  // value cleared.
                  if (this.mBrowser.userTypedClear > 1)
                    this.mBrowser.userTypedClear -= 2;
                  else if (this.mBrowser.userTypedClear > 0)
                    this.mBrowser.userTypedClear--;

                  if (!this.mBrowser.mIconURL)
                    this.mTabBrowser.useDefaultIcon(this.mTab);
                }

                if (this.mBlank)
                  this.mBlank = false;

                this.mTab.removeAttribute("busy");
                this.mTabBrowser.updateIcon(this.mTab);

                var location = aRequest.QueryInterface(nsIChannel).URI;

                // For keyword URIs clear the user typed value since they will be changed into real URIs
                if (location.scheme == "keyword")
                  this.mBrowser.userTypedValue = null;

                if (this.mTab.label == this.mTabBrowser.mStringBundle.getString("tabs.loading"))
                  this.mTabBrowser.setTabTitle(this.mTab);

                if (this.mTabBrowser.mCurrentTab == this.mTab)
                  this.mTabBrowser.mIsBusy = false;
              }

              if (this.mTabBrowser.mCurrentTab == this.mTab) {
                for (let i = 0; i < this.mTabBrowser.mProgressListeners.length; i++) {
                  let p = this.mTabBrowser.mProgressListeners[i];
                  if (p)
                    try {
                      if (!oldBlank)
                        p.onStateChange(aWebProgress, aRequest, aStateFlags, aStatus);
                      // make sure that the visible status of new blank tabs is correctly set
                      else if ("onUpdateCurrentBrowser" in p)
                        p.onUpdateCurrentBrowser(aStateFlags, aStatus, "", 0);
                    } catch (e) {
                      // don't inhibit other listeners
                      Components.utils.reportError(e);
                    }
                }
              }

              for (let i = 0; i < this.mTabBrowser.mTabsProgressListeners.length; i++) {
                let p = this.mTabBrowser.mTabsProgressListeners[i];
                if (p)
                  try {
                    p.onStateChange(this.mBrowser, aWebProgress, aRequest, aStateFlags, aStatus);
                  } catch (e) {
                    // don't inhibit other listeners
                    Components.utils.reportError(e);
                  }
              }

              if (aStateFlags & (nsIWebProgressListener.STATE_START |
                                 nsIWebProgressListener.STATE_STOP)) {
                // reset cached temporary values at beginning and end
                this.mMessage = "";
                this.mTotalProgress = 0;
              }
              this.mStateFlags = aStateFlags;
              this.mStatus = aStatus;
            },

            onLocationChange : function(aWebProgress, aRequest, aLocation)
            {
              // The document loaded correctly, clear the value if we should
              if (this.mBrowser.userTypedClear > 0)
                this.mBrowser.userTypedValue = null;

              if (aWebProgress.DOMWindow == this.mBrowser.contentWindow &&
                  aWebProgress.isLoadingDocument)
                this.mTabBrowser.getBrowserForTab(this.mTab).mIconURL = null;

              // changing location, clear out the missing plugins list
              this.mBrowser.missingPlugins = null;

              if (this.mBlank)
                return;

              if (this.mTabBrowser.mCurrentTab == this.mTab) {
                for (let i = 0; i < this.mTabBrowser.mProgressListeners.length; i++) {
                  let p = this.mTabBrowser.mProgressListeners[i];
                  if (p)
                    try {
                      p.onLocationChange(aWebProgress, aRequest, aLocation);
                    } catch (e) {
                      // don't inhibit other listeners
                      Components.utils.reportError(e);
                    }
                }
              }

              for (let i = 0; i < this.mTabBrowser.mTabsProgressListeners.length; i++) {
                let p = this.mTabBrowser.mTabsProgressListeners[i];
                if (p)
                  try {
                    p.onLocationChange(this.mBrowser, aWebProgress, aRequest, aLocation);
                  } catch (e) {
                    // don't inhibit other listeners
                    Components.utils.reportError(e);
                  }
              }
            },

            onStatusChange : function(aWebProgress, aRequest, aStatus, aMessage)
            {
              if (this.mBlank)
                return;

              if (this.mTabBrowser.mCurrentTab == this.mTab) {
                for (let i = 0; i < this.mTabBrowser.mProgressListeners.length; i++) {
                  let p = this.mTabBrowser.mProgressListeners[i];
                  if (p)
                    try {
                      p.onStatusChange(aWebProgress, aRequest, aStatus, aMessage);
                    } catch (e) {
                      // don't inhibit other listeners
                      Components.utils.reportError(e);
                    }
                }
              }

              for (let i = 0; i < this.mTabBrowser.mTabsProgressListeners.length; i++) {
                let p = this.mTabBrowser.mTabsProgressListeners[i];
                if (p)
                  try {
                    p.onStatusChange(this.mBrowser, aWebProgress, aRequest, aStatus, aMessage);
                  } catch (e) {
                    // don't inhibit other listeners
                    Components.utils.reportError(e);
                  }
              }

              this.mMessage = aMessage;
            },

            onSecurityChange : function(aWebProgress, aRequest, aState)
            {
              if (this.mTabBrowser.mCurrentTab == this.mTab) {
                for (let i = 0; i < this.mTabBrowser.mProgressListeners.length; i++) {
                  let p = this.mTabBrowser.mProgressListeners[i];
                  if (p)
                    try {
                      p.onSecurityChange(aWebProgress, aRequest, aState);
                    } catch (e) {
                      // don't inhibit other listeners
                      Components.utils.reportError(e);
                    }
                }
              }

              for (let i = 0; i < this.mTabBrowser.mTabsProgressListeners.length; i++) {
                let p = this.mTabBrowser.mTabsProgressListeners[i];
                if (p)
                  try {
                    p.onSecurityChange(this.mBrowser, aWebProgress, aRequest, aState);
                  } catch (e) {
                    // don't inhibit other listeners
                    Components.utils.reportError(e);
                  }
              }
            },

            onRefreshAttempted : function(aWebProgress, aURI, aDelay, aSameURI)
            {
              var allowRefresh = true;
              if (this.mTabBrowser.mCurrentTab == this.mTab) {
                for (let i = 0; i < this.mTabBrowser.mProgressListeners.length; i++) {
                  let p = this.mTabBrowser.mProgressListeners[i];
                  if (p && "onRefreshAttempted" in p) {
                    try {
                      if (!p.onRefreshAttempted(aWebProgress, aURI, aDelay, aSameURI))
                        allowRefresh = false;
                     } catch (e) {
                       // don't inhibit other listeners
                       Components.utils.reportError(e);
                     }
                  }
                }
              }

              for (let i = 0; i < this.mTabBrowser.mTabsProgressListeners.length; i++) {
                let p = this.mTabBrowser.mTabsProgressListeners[i];
                if (p && "onRefreshAttempted" in p) {
                  try {
                    if (!p.onRefreshAttempted(this.mBrowser, aWebProgress, aURI, aDelay, aSameURI))
                      allowRefresh = false;
                   } catch (e) {
                     // don't inhibit other listeners
                     Components.utils.reportError(e);
                   }
                }
              }
              return allowRefresh;
            },

            QueryInterface : function(aIID)
            {
              if (aIID.equals(Components.interfaces.nsIWebProgressListener) ||
                  aIID.equals(Components.interfaces.nsIWebProgressListener2) ||
                  aIID.equals(Components.interfaces.nsISupportsWeakReference) ||
                  aIID.equals(Components.interfaces.nsISupports))
                return this;
              throw Components.results.NS_NOINTERFACE;
            }
          });
        ]]>
        </body>
      </method>

      <method name="updateCurrentBrowser">
        <parameter name="aForceUpdate"/>
        <body>
          <![CDATA[
            var newBrowser = this.getBrowserAtIndex(this.mTabContainer.selectedIndex);
            if (this.mCurrentBrowser == newBrowser && !aForceUpdate)
              return;

            // Preview mode should not reset the owner
            if (!this._previewMode && this.mCurrentTab != this.selectedTab)
              this.mCurrentTab.owner = null;

            this._lastRelatedTab = null;

            var oldBrowser = this.mCurrentBrowser;
            if (oldBrowser)
              oldBrowser.setAttribute("type", "content-targetable");

            var updatePageReport = false;
            if (!oldBrowser ||
                (oldBrowser.pageReport && !newBrowser.pageReport) ||
                (!oldBrowser.pageReport && newBrowser.pageReport))
              updatePageReport = true;

            /* philiKON's changes here */
            if (newBrowser.getAttribute("putitonmytap") == "true") {
              var evt = document.createEvent("Event");
              evt.initEvent("BarTapLoad", true, true);
              newBrowser.dispatchEvent(evt);
            }

            newBrowser.setAttribute("type", "content-primary");
            this.mCurrentBrowser = newBrowser;
            this.mCurrentTab = this.selectedTab;

            if (updatePageReport)
              this.mCurrentBrowser.updatePageReport();

            // Update the URL bar.
            var loc = this.mCurrentBrowser.currentURI;

            var webProgress = this.mCurrentBrowser.webProgress;
            var securityUI = this.mCurrentBrowser.securityUI;

            var i, p;
            for (i = 0; i < this.mProgressListeners.length; i++) {
              p = this.mProgressListeners[i];
              if (p)
                try {
                  p.onLocationChange(webProgress, null, loc);
                  if (securityUI)
                    p.onSecurityChange(webProgress, null, securityUI.state);

                  // make sure that all status indicators are properly updated
                  if ("onUpdateCurrentBrowser" in p) {
                    var listener = this.mTabListeners[this.mTabContainer.selectedIndex] || null;
                    if (listener && listener.mStateFlags)
                      p.onUpdateCurrentBrowser(listener.mStateFlags, listener.mStatus,
                                               listener.mMessage, listener.mTotalProgress);
                  }
                } catch (e) {
                  // don't inhibit other listeners or following code
                  Components.utils.reportError(e);
                }
            }

            // Don't switch the fast find - this tab switch is temporary
            if (!this._previewMode)
              this._fastFind.setDocShell(this.mCurrentBrowser.docShell);

            // Update the window title.
            this.updateTitlebar();

            // If the new tab is busy, and our current state is not busy, then
            // we need to fire a start to all progress listeners.
            const nsIWebProgressListener = Components.interfaces.nsIWebProgressListener;
            if (this.mCurrentTab.hasAttribute("busy") && !this.mIsBusy) {
              this.mIsBusy = true;
              webProgress = this.mCurrentBrowser.webProgress;
              for (i = 0; i < this.mProgressListeners.length; i++) {
                p = this.mProgressListeners[i];
                if (p)
                  try {
                    p.onStateChange(webProgress, null, nsIWebProgressListener.STATE_START | nsIWebProgressListener.STATE_IS_NETWORK, 0);
                  } catch (e) {
                    // don't inhibit other listeners or following code
                    Components.utils.reportError(e);
                  }
              }
            }

            // If the new tab is not busy, and our current state is busy, then
            // we need to fire a stop to all progress listeners.
            if (!this.mCurrentTab.hasAttribute("busy") && this.mIsBusy) {
              this.mIsBusy = false;
              webProgress = this.mCurrentBrowser.webProgress;
              for (i = 0; i < this.mProgressListeners.length; i++) {
                p = this.mProgressListeners[i];
                if (p)
                  try {
                    p.onStateChange(webProgress, null, nsIWebProgressListener.STATE_STOP | nsIWebProgressListener.STATE_IS_NETWORK, 0);
                  } catch (e) {
                    // don't inhibit other listeners or following code
                    Components.utils.reportError(e);
                  }
              }
            }

            // TabSelect events are suppressed during preview mode to avoid confusing extensions and other bits of code
            // that might rely upon the other changes suppressed.
            // Focus is suppressed in the event that the main browser window is minimized - focusing a tab would restore the window
            if (!this._previewMode) {
              // We've selected the new tab, so go ahead and notify listeners.
              var event = document.createEvent("Events");
              event.initEvent("TabSelect", true, false);
              this.mCurrentTab.dispatchEvent(event);

              // Change focus to the new browser unless the findbar is focused.
              if (gFindBar.hidden ||
                  gFindBar.getElement("findbar-textbox").getAttribute("focused") != "true")
                newBrowser.focus();
            }
          ]]>
        </body>
      </method>

      <method name="addTab">
        <parameter name="aURI"/>
        <parameter name="aReferrerURI"/>
        <parameter name="aCharset"/>
        <parameter name="aPostData"/>
        <parameter name="aOwner"/>
        <parameter name="aAllowThirdPartyFixup"/>
        <body>
          <![CDATA[
            var aRelatedToCurrent;
            if (arguments.length == 2 &&
                typeof arguments[1] == "object" &&
                !(arguments[1] instanceof Ci.nsIURI)) {
              let params = arguments[1];
              aReferrerURI          = params.referrerURI;
              aCharset              = params.charset;
              aPostData             = params.postData;
              aOwner                = params.ownerTab;
              aAllowThirdPartyFixup = params.allowThirdPartyFixup;
              aRelatedToCurrent     = params.relatedToCurrent;
            }

            this._browsers = null; // invalidate cache

            if (!this.mTabbedMode)
              this.enterTabbedMode();

            // if we're adding tabs, we're past interrupt mode, ditch the owner
            if (this.mCurrentTab.owner)
              this.mCurrentTab.owner = null;

            var t = document.createElementNS(
              "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul",
                                             "tab");

            var blank = (aURI == "about:blank");

            if (blank)
              t.setAttribute("label", this.mStringBundle.getString("tabs.untitled"));
            else
              t.setAttribute("label", aURI);

            t.setAttribute("crop", "end");
            t.maxWidth = this.mTabContainer.mTabMaxWidth;
            t.minWidth = this.mTabContainer.mTabMinWidth;
            t.width = 0;
            t.setAttribute("flex", "100");
            t.setAttribute("validate", "never");
            t.setAttribute("onerror", "this.removeAttribute('image');");
            t.className = "tabbrowser-tab";

            this.mTabContainer.appendChild(t);

            if (this.tabContainer.mTabstrip._isRTLScrollbox) {
              /* In RTL UI, the tab is visually added to the left side of the
               * tabstrip. This means the tabstip has to be scrolled back in
               * order to make sure the same set of tabs is visible before and
               * after the new tab is added.  See bug 508816. */

              this.tabContainer.mTabstrip.scrollByPixels(this.mTabs[0].clientWidth);
            }

            // invalidate cache, because mTabContainer is about to change
            this._browsers = null; 

            // If this new tab is owned by another, assert that relationship
            if (aOwner)
              t.owner = aOwner;

            var b = document.createElementNS(
              "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul",
                                             "browser");
            b.setAttribute("type", "content-targetable");
            b.setAttribute("message", "true");
            b.setAttribute("contextmenu", this.getAttribute("contentcontextmenu"));
            b.setAttribute("tooltip", this.getAttribute("contenttooltip"));
            if (this.hasAttribute("autocompletepopup"))
              b.setAttribute("autocompletepopup", this.getAttribute("autocompletepopup"));
            b.setAttribute("autoscrollpopup", this._autoScrollPopup.id);

            // Add the Message and the Browser to the box
            var notificationbox = document.createElementNS(
                                    "http://www.mozilla.org/keymaster/gatekeeper/there.is.only.xul",
                                    "notificationbox");
            notificationbox.setAttribute("flex", "1");
            notificationbox.appendChild(b);
            b.setAttribute("flex", "1");
            this.mPanelContainer.appendChild(notificationbox);

            b.addEventListener("DOMTitleChanged", this.onTitleChanged, true);

            if (this.mStrip.collapsed)
              this.setStripVisibilityTo(true);

            // wire up a progress listener for the new browser object.
            var position = this.mTabContainer.childNodes.length-1;
            var tabListener = this.mTabProgressListener(t, b, blank);
            const filter = Components.classes["@mozilla.org/appshell/component/browser-status-filter;1"]
                                     .createInstance(Components.interfaces.nsIWebProgress);
            filter.addProgressListener(tabListener, Components.interfaces.nsIWebProgress.NOTIFY_ALL);
            b.webProgress.addProgressListener(filter, Components.interfaces.nsIWebProgress.NOTIFY_ALL);
            this.mTabListeners[position] = tabListener;
            this.mTabFilters[position] = filter;

            b._fastFind = this.fastFind;

            var uniqueId = "panel" + Date.now() + position;
            this.mPanelContainer.lastChild.id = uniqueId;
            t.linkedPanel = uniqueId;
            t.linkedBrowser = b;
            t._tPos = position;
            if (t.previousSibling.selected)
              t.setAttribute("afterselected", true);

            this.tabContainer.adjustTabstrip();

            // Do this asynchronically, as we don't know yet if the tab
            // will be selected.
            setTimeout(function (aTabContainer) {
              if (aTabContainer.selectedItem != t)
                aTabContainer._notifyBackgroundTab(t);
            }, 0, this.tabContainer);

            // XXXmano: this is a temporary workaround for bug 345399
            // We need to manually update the scroll buttons disabled state
            // if a tab was inserted to the overflow area or removed from it
            // without any scrolling and when the tabbar has already
            // overflowed.
            this.tabContainer.mTabstrip._updateScrollButtonsDisabledState();

            // Dispatch a new tab notification.  We do this once we're
            // entirely done, so that things are in a consistent state
            // even if the event listener opens or closes tabs.
            var evt = document.createEvent("Events");
            evt.initEvent("TabOpen", true, false);
            t.dispatchEvent(evt);

            if (!blank) {
              // Stop the existing about:blank load.  Otherwise, if aURI
              // doesn't stop in-progress loads on its own, we'll get into
              // trouble with multiple parallel loads running at once.
              b.stop();

              // pretend the user typed this so it'll be available till
              // the document successfully loads
              b.userTypedValue = aURI;

              let flags = aAllowThirdPartyFixup ?
                          Ci.nsIWebNavigation.LOAD_FLAGS_ALLOW_THIRD_PARTY_FIXUP :
                          Ci.nsIWebNavigation.LOAD_FLAGS_NONE;

              /* philiKON's changes here */
              let bartap = "";
              if (aURI) {
                bartap = JSON.stringify({
                  uri:      (aURI instanceof Ci.nsIURI) ? aURI.spec : aURI,
                  flags:    flags,
                  referrer: (aReferrerURI instanceof Ci.nsIURI) ? aReferrerURI.spec : aReferrerURI,
                  charset:  aCharset,
                  postdata: aPostData
                });
              }
              b.setAttribute("putitonmytap", "true");
              b.setAttribute("bartap", bartap);

              try {
                b.loadURIWithFlags(aURI, flags, aReferrerURI, aCharset, aPostData);
              }
              catch (ex) { }
            }

            // Check if we're opening a tab related to the current tab and
            // move it to after the current tab.
            // aReferrerURI is null or undefined if the tab is opened from
            // an external application or bookmark, i.e. somewhere other
            // than the current tab.
            if ((aRelatedToCurrent == null ? aReferrerURI : aRelatedToCurrent) &&
                this.mPrefs.getBoolPref("browser.tabs.insertRelatedAfterCurrent")) {
              let newTabPos = (this._lastRelatedTab ||
                               this.selectedTab)._tPos + 1;
              this.moveTabTo(t, newTabPos);
              this._lastRelatedTab = t;
            }

            return t;
          ]]>
        </body>
      </method>

    </implementation>

  </binding>

</bindings>
